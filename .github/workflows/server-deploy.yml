name: Server Deploy

on:
  push:
    branches: [main]
    paths:
      - "apps/server/**"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # GitHub Actions IP 가져오기
      - name: Get Public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 보안 그룹에 GitHub Actions IP 추가
      - name: Add GitHub Actions IP to Security Group
        run: |
          aws ec2 authorize-security-group-ingress \
              --group-id ${{ secrets.BACKEND_SECURITY_GROUP_ID }} \
              --protocol tcp \
              --port 22 \
              --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.BACKEND_HOST }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # 배포 시작 로그
            echo "=== 서버 블루-그린 배포 시작 ==="

            # 프로젝트 디렉토리로 이동
            cd ~/amp_music/apps/server

            # 변경사항 가져오기
            git fetch --all
            git reset --hard origin/main

            # 현재 활성 환경 확인 (blue 또는 green)
            CURRENT_ENV=""
            CURRENT_PORT=""
            NEW_ENV=""
            NEW_PORT=""

            if docker ps | grep -q "amp_backend_blue"; then
              CURRENT_ENV="blue"
              CURRENT_PORT="4000"
              NEW_ENV="green"
              NEW_PORT="4001"
              echo "현재 활성 환경: BLUE (포트: 4000)"
            elif docker ps | grep -q "amp_backend_green"; then
              CURRENT_ENV="green"
              CURRENT_PORT="4001"
              NEW_ENV="blue"
              NEW_PORT="4000"
              echo "현재 활성 환경: GREEN (포트: 4001)"
            elif docker ps | grep -q "amp_backend"; then
              # 기존 단일 컨테이너 환경 발견
              echo "기존 단일 컨테이너 'amp_backend' 발견. 블루-그린 배포로 전환합니다."
              CURRENT_ENV="legacy"
              CURRENT_PORT="4000"  # 기존 컨테이너는 4000 포트 사용 중
              NEW_ENV="blue"       # 첫 블루-그린 배포는 blue로 시작
              NEW_PORT="4000"      # 동일한 포트 사용 (기존 컨테이너는 배포 전에 제거)
            else
              # 초기 배포 시 blue로 시작
              CURRENT_ENV=""
              CURRENT_PORT=""
              NEW_ENV="blue"
              NEW_PORT="4000"
              echo "초기 배포: BLUE 환경으로 시작 (포트: 4000)"
            fi

            # 기존 레거시 컨테이너 처리
            if [ "$CURRENT_ENV" = "legacy" ]; then
              echo "기존 레거시 컨테이너를 종료하고 블루-그린 배포를 시작합니다."
              # 현재 설정 백업
              sudo cp /etc/nginx/sites-available/api.ampmusic.im /etc/nginx/sites-available/api.ampmusic.im.backup.legacy
              
              # 기존 컨테이너의 이미지 태그 확인 (롤백을 위해)
              LEGACY_IMAGE=$(docker inspect --format='{{.Config.Image}}' amp_backend)
              echo "기존 이미지 정보 저장: $LEGACY_IMAGE"
              
              # 기존 컨테이너 종료 (도커 컴포즈 파일은 그대로 유지)
              echo "기존 레거시 컨테이너 종료 중..."
              docker stop amp_backend
              docker rm amp_backend
            fi

            # docker-compose 파일 수정 또는 생성
            cat > docker-compose.${NEW_ENV}.yml << EOL
            services:
              backend:
                build:
                  context: .
                  dockerfile: Dockerfile
                container_name: amp_backend_${NEW_ENV}
                network_mode: "host"
                environment:
                  - NODE_ENV=production
                  - ELASTICSEARCH_URL=http://127.0.0.1:9200
                  - REDIS_URL=redis://127.0.0.1:6379
                  - PORT=${NEW_PORT}
                env_file:
                  - .env
                volumes:
                  - type: bind
                    source: ./uploads
                    target: /app/uploads
                restart: unless-stopped
            EOL

            # .env 파일 권한 수정 (임시로 읽기 권한 부여)
            chmod 644 .env

            # 환경 변수 확인 및 DATABASE_URL 직접 추가
            if grep -q DATABASE_URL .env; then
              # 환경 변수 값 추출 (잘라내기 방지를 위해 일부만 표시)
              DB_URL=$(grep DATABASE_URL .env | cut -d= -f2-)
              
              # DATABASE_URL이 localhost를 가리키는지 확인
              if echo "$DB_URL" | grep -q "@localhost:"; then
                echo "경고: DATABASE_URL이 로컬호스트를 가리키고 있습니다. RDS 엔드포인트를 사용해야 합니다."
                echo "현재 설정: $DB_URL"
                echo "배포가 실패할 가능성이 높습니다!"
              else
                echo "설정된 DATABASE_URL 확인: ${DB_URL:0:10}...${DB_URL: -10}"
              fi
              
              # DATABASE_URL에 RDS 연결 테스트
              DB_HOST=$(echo "$DB_URL" | sed -E 's/.*@([^:]+):.*/\1/')
              echo "데이터베이스 호스트: $DB_HOST"
              
              if [ ! -z "$DB_HOST" ] && [ "$DB_HOST" != "localhost" ]; then
                echo "DB 연결 테스트 중..."
                if nc -zv $DB_HOST 5432; then
                  echo "데이터베이스 연결 성공!"
                else
                  echo "경고: 데이터베이스 연결 실패! 배포가 실패할 가능성이 높습니다."
                fi
              fi
              
              # DB_URL에 프로토콜이 없는 경우 추가
              if ! echo "$DB_URL" | grep -q "^\"*postgresql://\|^\"*postgres://"; then
                echo "DATABASE_URL에 프로토콜이 없습니다. postgresql:// 프로토콜을 추가합니다."
                # 따옴표가 있는 경우 처리
                if [[ "$DB_URL" == \"* ]]; then
                  DB_URL="\"postgresql://${DB_URL:1}"
                else
                  DB_URL="postgresql://$DB_URL"
                fi
                echo "수정된 DATABASE_URL: ${DB_URL:0:20}...${DB_URL: -10}"
              fi
              
              # docker-compose 파일에 직접 DATABASE_URL 추가
              sed -i "/- PORT=\${NEW_PORT}/a \                  - DATABASE_URL=${DB_URL}" docker-compose.${NEW_ENV}.yml
              
              # .env 파일의 DATABASE_URL도 업데이트 (Prisma가 .env 파일에서 읽기 때문에)
              sed -i "s|^DATABASE_URL=.*|DATABASE_URL=${DB_URL}|" .env
              echo "수정된 .env 파일의 DATABASE_URL 업데이트 완료"
            else
              echo "경고: .env 파일에 DATABASE_URL이 설정되어 있지 않습니다."
            fi
            
            # PORT 환경 변수가 docker-compose 파일과 일치하는지 확인
            echo "컨테이너 포트 확인 중: ${NEW_PORT}"
            sed -i "s|PORT=4000|PORT=${NEW_PORT}|" .env
            echo "임시 .env 파일에 PORT=${NEW_PORT} 설정 완료"
            
            echo "새 환경 ${NEW_ENV} 배포 준비 (포트: ${NEW_PORT})"

            # 기존에 같은 이름의 컨테이너가 있다면 제거
            if docker ps -a | grep -q "amp_backend_${NEW_ENV}"; then
              echo "기존 ${NEW_ENV} 컨테이너 제거 중..."
              docker rm -f amp_backend_${NEW_ENV}
            fi

            # Docker 캐시 정리 (이미지 충돌 방지)
            docker system prune -f

            # 새 환경 배포
            echo "새 환경 ${NEW_ENV} 배포 시작..."
            COMPOSE_FILE="docker-compose.${NEW_ENV}.yml"
            if docker-compose -f ${COMPOSE_FILE} build && docker-compose -f ${COMPOSE_FILE} up -d; then
              echo "Docker Compose를 통한 배포 성공"
            else
              echo "Docker Compose 배포 실패, 직접 Docker 실행으로 대체..."
              
              # Docker 직접 실행으로 대체
              echo "이미지 빌드 중..."
              docker build -t amp_backend:${NEW_ENV} .
              
              echo "컨테이너 실행 중..."
              # 환경 변수 추출
              DB_URL=$(grep DATABASE_URL .env | cut -d= -f2-)
              
              # 컨테이너 직접 실행
              docker run -d --network host --name amp_backend_${NEW_ENV} \
                -v $(pwd)/uploads:/app/uploads \
                -e NODE_ENV=production \
                -e ELASTICSEARCH_URL=http://127.0.0.1:9200 \
                -e REDIS_URL=redis://127.0.0.1:6379 \
                -e PORT=${NEW_PORT} \
                -e DATABASE_URL="${DB_URL}" \
                --restart unless-stopped \
                amp_backend:${NEW_ENV}
                
              echo "Docker 직접 실행으로 컨테이너 생성 완료"
            fi

            # 배포 완료 대기 (초기 안정화)
            echo "새 버전 안정화 대기 중..."
            sleep 10

            # 컨테이너 로그 확인
            echo "새 컨테이너 로그 확인 중..."
            docker logs amp_backend_${NEW_ENV} --tail 50 || true

            # 환경 변수 상태 확인
            echo "컨테이너 내 환경 변수 확인 중..."
            docker exec amp_backend_${NEW_ENV} env | grep -v PASSWORD || true

            # 새 버전 헬스 체크
            echo "새 버전 헬스 체크 시작..."
            HEALTH_CHECK_PASS=false

            for i in {1..6}; do
              echo "헬스 체크 시도 ${i}/6..."
              RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${NEW_PORT}/health || echo "000")
              
              if [[ "$RESPONSE_CODE" == "200" ]]; then
                echo "헬스 체크 성공! (응답 코드: ${RESPONSE_CODE})"
                HEALTH_CHECK_PASS=true
                break
              fi
              
              echo "헬스 체크 실패 (응답 코드: ${RESPONSE_CODE}), 재시도 중..."
              sleep 5
            done

            if [ "$HEALTH_CHECK_PASS" = true ]; then
              echo "새 버전 검증 완료, 트래픽 전환 준비..."
              
              # Nginx 설정 업데이트
              sudo cp /etc/nginx/sites-available/api.ampmusic.im /etc/nginx/sites-available/api.ampmusic.im.backup
              
              sudo bash -c "cat > /etc/nginx/sites-available/api.ampmusic.im << 'EOL'
            server {
                listen 80;
                server_name api.ampmusic.im;

                # 파일 업로드 크기 제한 설정 (25MB로 설정)
                client_max_body_size 25M;

                location / {
                    proxy_pass http://localhost:${NEW_PORT};
                    proxy_http_version 1.1;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection \"upgrade\";

                    # CORS 설정
                    add_header Access-Control-Allow-Origin \"https://ampmusic.im\" always;
                    add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, PUT, DELETE\" always;
                    add_header Access-Control-Allow-Headers \"DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-XSRF-TOKEN\" always;
                    add_header Access-Control-Expose-Headers \"Content-Length,Content-Range\" always;

                    # OPTIONS 요청 처리
                    if (\$request_method = 'OPTIONS') {
                        add_header Access-Control-Allow-Origin \"https://ampmusic.im\" always;
                        add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, PUT, DELETE\" always;
                        add_header Access-Control-Allow-Headers \"DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-XSRF-TOKEN\" always;
                        add_header Access-Control-Max-Age 1728000;
                        add_header Content-Type 'text/plain charset=UTF-8';
                        add_header Content-Length 0;
                        return 204;
                    }
                }
            }
            EOL"
              
              # Nginx 설정 유효성 검사 및 리로드
              sudo nginx -t
              if [ $? -eq 0 ]; then
                echo "Nginx 설정 유효성 검사 통과, 설정 적용 중..."
                sudo systemctl reload nginx
                
                echo "트래픽을 ${NEW_ENV} 환경(포트: ${NEW_PORT})으로 전환 완료"
                
                # 이전 환경 유지 (그레이스 기간 - 롤백 가능성)
                if [ ! -z "$CURRENT_ENV" ]; then
                  echo "이전 환경(${CURRENT_ENV})은 10초 동안 유지 후 종료됩니다..."
                  sleep 10
                  
                  # 이전 환경 종료
                  if docker ps | grep -q "amp_backend_${CURRENT_ENV}"; then
                    echo "이전 환경(${CURRENT_ENV}) 종료 중..."
                    docker rm -f amp_backend_${CURRENT_ENV}
                  elif [ "$CURRENT_ENV" = "legacy" ] && docker ps | grep -q "amp_backend"; then
                    echo "레거시 환경 종료 중..."
                    docker rm -f amp_backend
                  fi
                fi
                
                # 기존 docker-compose.yml 백업 및 현재 설정 저장
                if [ -f "docker-compose.yml" ]; then
                  cp docker-compose.yml docker-compose.yml.backup
                fi
                
                # 현재 동작 중인 환경 설정을 기본 docker-compose.yml로 저장
                cp docker-compose.${NEW_ENV}.yml docker-compose.yml
                echo "docker-compose 설정을 업데이트했습니다."
                
                echo "=== 서버 블루-그린 배포 성공 ==="
                exit 0
              else
                echo "Nginx 설정 유효성 검사 실패, 롤백 진행..."
                sudo cp /etc/nginx/sites-available/api.ampmusic.im.backup /etc/nginx/sites-available/api.ampmusic.im
                sudo systemctl reload nginx
                
                # 새 배포 실패, 컨테이너 제거
                docker rm -f amp_backend_${NEW_ENV}
                
                echo "Nginx 설정 오류로 인한 롤백 완료"
                exit 1
              fi
            else
              echo "새 버전 헬스 체크 실패, 롤백 진행..."
              
              # 새 배포 실패, 컨테이너 제거
              docker rm -f amp_backend_${NEW_ENV}
              
              # 레거시 환경으로 롤백 처리
              if [ "$CURRENT_ENV" = "legacy" ] && [ ! -z "$LEGACY_IMAGE" ]; then
                echo "레거시 환경으로 롤백합니다..."
                
                # 레거시 이미지로 컨테이너 실행
                docker run -d --network host --name amp_backend \
                  -v $(pwd)/uploads:/app/uploads \
                  -v $(pwd)/.env:/app/.env \
                  -e PORT=4000 \
                  --restart unless-stopped \
                  $LEGACY_IMAGE
                
                # Nginx 설정 복구
                sudo cp /etc/nginx/sites-available/api.ampmusic.im.backup.legacy /etc/nginx/sites-available/api.ampmusic.im
                sudo systemctl reload nginx
                
                echo "레거시 환경으로 롤백 완료"
              fi
              
              echo "=== 서버 블루-그린 배포 실패, 롤백 완료 ==="
              exit 1
            fi

      # 보안 그룹에서 GitHub Actions IP 제거
      - name: Remove GitHub Actions IP from Security Group
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
              --group-id ${{ secrets.BACKEND_SECURITY_GROUP_ID }} \
              --protocol tcp \
              --port 22 \
              --cidr ${{ steps.ip.outputs.ipv4 }}/32