name: Server Deploy

on:
  push:
    branches: [main]
    paths:
      - "apps/server/**"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # GitHub Actions IP 가져오기
      - name: Get Public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 보안 그룹에 GitHub Actions IP 추가
      - name: Add GitHub Actions IP to Security Group
        run: |
          aws ec2 authorize-security-group-ingress \
              --group-id ${{ secrets.BACKEND_SECURITY_GROUP_ID }} \
              --protocol tcp \
              --port 22 \
              --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.BACKEND_HOST }}
          username: ubuntu
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # 배포 시작 로그
            echo "=== 서버 블루-그린 배포 시작 ==="
            
            # 프로젝트 디렉토리로 이동
            cd ~/amp_music/apps/server
            
            # 변경사항 가져오기
            git fetch --all
            git reset --hard origin/main
            
            # 현재 활성 환경 확인 (blue 또는 green)
            CURRENT_ENV=""
            CURRENT_PORT=""
            NEW_ENV=""
            NEW_PORT=""
            
            if docker ps | grep -q "amp_backend_blue"; then
              CURRENT_ENV="blue"
              CURRENT_PORT="4000"
              NEW_ENV="green"
              NEW_PORT="4001"
              echo "현재 활성 환경: BLUE (포트: 4000)"
            elif docker ps | grep -q "amp_backend_green"; then
              CURRENT_ENV="green"
              CURRENT_PORT="4001"
              NEW_ENV="blue"
              NEW_PORT="4000"
              echo "현재 활성 환경: GREEN (포트: 4001)"
            elif docker ps | grep -q "amp_backend"; then
              # 기존 단일 컨테이너 환경 발견
              echo "기존 단일 컨테이너 'amp_backend' 발견. 블루-그린 배포로 전환합니다."
              CURRENT_ENV="legacy"
              CURRENT_PORT="4000"  # 기존 컨테이너는 4000 포트 사용 중
              NEW_ENV="blue"       # 첫 블루-그린 배포는 blue로 시작
              NEW_PORT="4000"      # 동일한 포트 사용 (기존 컨테이너는 배포 전에 제거)
            else
              # 초기 배포 시 blue로 시작
              CURRENT_ENV=""
              CURRENT_PORT=""
              NEW_ENV="blue"
              NEW_PORT="4000"
              echo "초기 배포: BLUE 환경으로 시작 (포트: 4000)"
            fi
            
            # 기존 레거시 컨테이너 처리
            if [ "$CURRENT_ENV" = "legacy" ]; then
              echo "기존 레거시 컨테이너를 종료하고 블루-그린 배포를 시작합니다."
              # 현재 설정 백업
              sudo cp /etc/nginx/sites-available/api.ampmusic.im /etc/nginx/sites-available/api.ampmusic.im.backup.legacy
              
              # 기존 컨테이너의 이미지 태그 확인 (롤백을 위해)
              LEGACY_IMAGE=$(docker inspect --format='{{.Config.Image}}' amp_backend)
              echo "기존 이미지 정보 저장: $LEGACY_IMAGE"
              
              # 기존 컨테이너 종료 (도커 컴포즈 파일은 그대로 유지)
              echo "기존 레거시 컨테이너 종료 중..."
              docker stop amp_backend
              docker rm amp_backend
            fi
            
            # docker-compose 파일 수정 또는 생성
            # 주요 환경 변수 확인
            DATABASE_URL=$(grep DATABASE_URL .env | cut -d '=' -f2- || echo "")
            if [ -z "$DATABASE_URL" ]; then
              echo "경고: DATABASE_URL을 .env 파일에서 찾을 수 없습니다!"
            else
              echo "DATABASE_URL 환경 변수가 확인되었습니다."
            fi
            
            cat > docker-compose.${NEW_ENV}.yml << EOL
            version: '3.8'
            services:
              backend:
                build:
                  context: .
                  dockerfile: Dockerfile
                container_name: amp_backend_${NEW_ENV}
                network_mode: "host"
                environment:
                  - NODE_ENV=production
                  - ELASTICSEARCH_URL=http://127.0.0.1:9200
                  - REDIS_URL=redis://127.0.0.1:6379
                  - PORT=${NEW_PORT}
                  - DATABASE_URL=${DATABASE_URL}
                env_file:
                  - .env
                volumes:
                  - ./uploads:/app/uploads:Z
                restart: unless-stopped
            EOL
            
            # Dockerfile 내용 확인
            echo "Dockerfile 내용 확인:"
            cat Dockerfile
            
            echo "새 환경 ${NEW_ENV} 배포 준비 (포트: ${NEW_PORT})"
            
            # 기존에 같은 이름의 컨테이너가 있다면 제거
            if docker ps -a | grep -q "amp_backend_${NEW_ENV}"; then
              echo "기존 ${NEW_ENV} 컨테이너 제거 중..."
              docker rm -f amp_backend_${NEW_ENV}
            fi
            
            # Docker 캐시 정리 (이미지 충돌 방지)
            docker system prune -f
            
            # 포트 검사 및 정리
            echo "포트 ${NEW_PORT} 확인 중..."
            PORT_USAGE=$(netstat -tulpn 2>/dev/null | grep ":${NEW_PORT}" || echo "")
            if [ ! -z "$PORT_USAGE" ]; then
              echo "경고: 포트 ${NEW_PORT}가 이미 사용 중입니다: $PORT_USAGE"
              echo "포트를 사용 중인 프로세스 정보:"
              
              # 포트를 사용 중인 프로세스 PID 추출
              PORT_PID=$(echo "$PORT_USAGE" | awk '{print $7}' | cut -d'/' -f1)
              if [ ! -z "$PORT_PID" ]; then
                ps -f -p $PORT_PID || echo "프로세스 정보를 가져올 수 없습니다."
                
                echo "포트를 정리하는 중..."
                kill -9 $PORT_PID 2>/dev/null || echo "프로세스를 종료할 수 없습니다. 수동 확인이 필요합니다."
                sleep 2
                
                # 포트가 정리되었는지 다시 확인
                if netstat -tulpn 2>/dev/null | grep ":${NEW_PORT}" > /dev/null; then
                  echo "경고: 포트 ${NEW_PORT}를 정리할 수 없습니다. 계속 진행합니다..."
                else
                  echo "포트 ${NEW_PORT}가 정리되었습니다."
                fi
              fi
            else
              echo "포트 ${NEW_PORT}는 사용 가능합니다."
            fi
            
            # 새 환경 배포
            echo "새 환경 ${NEW_ENV} 배포 시작..."
            COMPOSE_FILE="docker-compose.${NEW_ENV}.yml"
            
            # Docker 버전 및 Compose 버전 확인
            echo "=== Docker 환경 정보 ==="
            docker --version
            docker-compose --version
            echo "========================="
            
            # 빌드 단계 분리 및 오류 처리 강화
            echo "Docker 이미지 빌드 시작..."
            if ! COMPOSE_API_VERSION=auto docker-compose -f ${COMPOSE_FILE} build --no-cache; then
              echo "❌ Docker 이미지 빌드 실패!"
              echo "빌드 로그 확인:"
              cat docker-compose.log || echo "로그 파일을 찾을 수 없습니다."
              exit 1
            fi
            echo "✅ Docker 이미지 빌드 성공!"
            
            # 컨테이너 시작 전 이미지 확인
            echo "빌드된 이미지 확인:"
            docker images | grep ${NEW_ENV} || echo "새 이미지를 찾을 수 없습니다."
            
            # 컨테이너 시작
            echo "컨테이너 시작 중..."
            if ! COMPOSE_API_VERSION=auto docker-compose -f ${COMPOSE_FILE} up -d; then
              echo "❌ Docker Compose로 컨테이너 시작 실패! 시스템 진단을 실행합니다."
              
              # 시스템 상태 진단
              echo "=== 시스템 상태 진단 ==="
              echo "디스크 공간:"
              df -h
              echo "메모리 사용량:"
              free -h
              echo "실행 중인 Docker 컨테이너:"
              docker ps -a
              echo "Docker 이미지:"
              docker images
              echo "Docker 볼륨:"
              docker volume ls
              echo "Docker 네트워크:"
              docker network ls
              echo "=== 진단 종료 ==="
              
              # Docker 로그 확인
              echo "Docker 데몬 로그 확인:"
              (journalctl -u docker --no-pager -n 50 || echo "Docker 로그를 가져올 수 없습니다.") | tail -n 50
              
              # 직접 실행 시도
              echo "Docker Compose 설정 디버깅:"
              docker-compose -f ${COMPOSE_FILE} config || echo "Docker Compose 설정 확인 실패"
              
              # 환경 차이 확인
              echo "블루/그린 환경 설정 차이 확인:"
              if [ "${NEW_ENV}" = "green" ]; then
                echo "그린 환경 특수 진단:"
                # 블루 환경 컨테이너와 설정 비교
                if docker ps | grep -q "amp_backend_blue"; then
                  echo "블루 환경 컨테이너 구성:"
                  docker inspect amp_backend_blue | grep -E "Image|Ports|NetworkMode"
                fi
                
                # 포트 4001 특수 진단
                echo "포트 4001 상태 심층 진단:"
                sudo ss -tulpn | grep ":4001" || echo "포트 4001은 사용 중이지 않습니다"
                sudo lsof -i :4001 || echo "lsof로 확인할 수 없습니다"
              fi
              
              # 이미지 이름 가져오기
              IMAGE_NAME=$(docker-compose -f ${COMPOSE_FILE} config | grep "image:" | head -n 1 | awk '{print $2}')
              if [ -z "$IMAGE_NAME" ]; then
                # 이미지 이름이 없으면 직접 빌드
                IMAGE_NAME="amp_backend_${NEW_ENV}:latest"
                echo "이미지 이름을 수동으로 설정: ${IMAGE_NAME}"
                docker build -t ${IMAGE_NAME} .
              fi
              
              echo "Docker run으로 직접 컨테이너 시작 시도: ${IMAGE_NAME}"
              
              # DATABASE_URL 환경 변수 확인 및 직접 전달
              DATABASE_URL=$(grep DATABASE_URL .env | cut -d '=' -f2- || echo "")
              if [ -z "$DATABASE_URL" ]; then
                echo "경고: DATABASE_URL을 .env 파일에서 찾을 수 없습니다!"
              else
                echo "DATABASE_URL 환경 변수가 확인되었습니다."
              fi
              
              if ! docker run -d --network host --name amp_backend_${NEW_ENV} \
                -e NODE_ENV=production \
                -e ELASTICSEARCH_URL=http://127.0.0.1:9200 \
                -e REDIS_URL=redis://127.0.0.1:6379 \
                -e PORT=${NEW_PORT} \
                -e DATABASE_URL="$DATABASE_URL" \
                --env-file .env \
                -v $(pwd)/uploads:/app/uploads \
                --restart unless-stopped \
                ${IMAGE_NAME}; then
                echo "❌ 직접 Docker 명령으로도 컨테이너 시작 실패!"
                
                # 추가 디버깅 정보
                echo "Docker 이미지 정보:"
                docker inspect ${IMAGE_NAME} || echo "이미지 정보를 가져올 수 없습니다."
                echo "Docker 오류 로그:"
                docker logs amp_backend_${NEW_ENV} 2>&1 || echo "로그를 가져올 수 없습니다."
                
                # 특정 환경 변수 문제 확인
                echo ".env 파일 확인 (민감 정보 제외):"
                grep -v -E "PASSWORD|SECRET|KEY" .env || echo ".env 파일을 확인할 수 없습니다."
                
                exit 1
              fi
              echo "✅ 직접 Docker 명령으로 컨테이너 시작 성공!"
            else
              echo "✅ Docker Compose로 컨테이너 시작 성공!"
            fi
            
            # 컨테이너 상태 확인
            echo "컨테이너 상태 확인:"
            docker ps -a | grep amp_backend_${NEW_ENV} || echo "컨테이너가 생성되지 않았습니다."
            
            # 컨테이너 로그 확인
            echo "컨테이너 로그 확인:"
            docker logs amp_backend_${NEW_ENV} --tail 50 || echo "컨테이너 로그를 가져올 수 없습니다."
            
            # 배포 완료 대기 (초기 안정화)
            echo "새 버전 안정화 대기 중..."
            sleep 10
            
            # 새 버전 헬스 체크
            echo "새 버전 헬스 체크 시작..."
            HEALTH_CHECK_PASS=false
            
            for i in {1..6}; do
              echo "헬스 체크 시도 ${i}/6..."
              # 기본 헬스 체크 - HTTP 상태 코드
              RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${NEW_PORT}/health || echo "000")
              
              if [[ "$RESPONSE_CODE" == "200" ]]; then
                echo "기본 헬스 체크 성공! (응답 코드: ${RESPONSE_CODE})"
                
                # 추가 헬스 체크 - 애플리케이션 상태 확인
                APP_STATUS=$(curl -s http://localhost:${NEW_PORT}/health || echo "{}")
                if [[ "$APP_STATUS" == *"\"status\":\"ok\""* ]] || [[ "$APP_STATUS" == *"\"status\":\"up\""* ]]; then
                  echo "애플리케이션 상태 확인 성공! 애플리케이션이 정상적으로 응답합니다."
                  HEALTH_CHECK_PASS=true
                  break
                else
                  echo "애플리케이션 응답은 받았으나 상태가 정상이 아닙니다: $APP_STATUS"
                fi
              fi
              
              echo "헬스 체크 실패 (응답 코드: ${RESPONSE_CODE}), 재시도 중..."
              # 로그 확인을 위해 컨테이너 로그 출력
              echo "컨테이너 로그 확인:"
              docker logs amp_backend_${NEW_ENV} --tail 20 || echo "로그를 가져올 수 없습니다."
              sleep 5
            done
            
            # 새 버전 헬스 체크 결과 로깅
            echo "=== 헬스 체크 최종 결과 ==="
            if [ "$HEALTH_CHECK_PASS" = true ]; then
              echo "✅ 헬스 체크 통과: 애플리케이션이 정상적으로 실행 중입니다."
              echo "==========================="
              
              echo "새 버전 검증 완료, 트래픽 전환 준비..."
              
              # 성공 기록 추가
              DEPLOY_LOG_DIR="deployment_logs"
              mkdir -p $DEPLOY_LOG_DIR
              TIMESTAMP=$(date "+%Y%m%d-%H%M%S")
              echo "${TIMESTAMP} - ${NEW_ENV} 환경 (포트: ${NEW_PORT}) 배포 성공" >> $DEPLOY_LOG_DIR/deploy_history.log
              
              # Nginx 설정 업데이트
              sudo cp /etc/nginx/sites-available/api.ampmusic.im /etc/nginx/sites-available/api.ampmusic.im.backup
              
              sudo bash -c "cat > /etc/nginx/sites-available/api.ampmusic.im << 'EOL'
            server {
                listen 80;
                server_name api.ampmusic.im;
            
                # 파일 업로드 크기 제한 설정 (25MB로 설정)
                client_max_body_size 25M;
            
                location / {
                    proxy_pass http://localhost:${NEW_PORT};
                    proxy_http_version 1.1;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection \"upgrade\";
            
                    # CORS 설정
                    add_header Access-Control-Allow-Origin \"https://ampmusic.im\" always;
                    add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, PUT, DELETE\" always;
                    add_header Access-Control-Allow-Headers \"DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-XSRF-TOKEN\" always;
                    add_header Access-Control-Expose-Headers \"Content-Length,Content-Range\" always;
            
                    # OPTIONS 요청 처리
                    if (\$request_method = 'OPTIONS') {
                        add_header Access-Control-Allow-Origin \"https://ampmusic.im\" always;
                        add_header Access-Control-Allow-Methods \"GET, POST, OPTIONS, PUT, DELETE\" always;
                        add_header Access-Control-Allow-Headers \"DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization,X-XSRF-TOKEN\" always;
                        add_header Access-Control-Max-Age 1728000;
                        add_header Content-Type 'text/plain charset=UTF-8';
                        add_header Content-Length 0;
                        return 204;
                    }
                }
            }
            EOL"
              
              # Nginx 설정 유효성 검사 및 리로드
              sudo nginx -t
              if [ $? -eq 0 ]; then
                echo "Nginx 설정 유효성 검사 통과, 설정 적용 중..."
                sudo systemctl reload nginx
                
                echo "트래픽을 ${NEW_ENV} 환경(포트: ${NEW_PORT})으로 전환 완료"
                
                # 이전 환경 유지 (그레이스 기간 - 롤백 가능성)
                if [ ! -z "$CURRENT_ENV" ]; then
                  echo "이전 환경(${CURRENT_ENV})은 10초 동안 유지 후 종료됩니다..."
                  sleep 10
                  
                  # 이전 환경 종료
                  if docker ps | grep -q "amp_backend_${CURRENT_ENV}"; then
                    echo "이전 환경(${CURRENT_ENV}) 종료 중..."
                    docker rm -f amp_backend_${CURRENT_ENV} || echo "이전 환경 컨테이너를 종료할 수 없습니다. 이미 제거되었을 수 있습니다."
                  elif [ "$CURRENT_ENV" = "legacy" ] && docker ps | grep -q "amp_backend"; then
                    echo "레거시 환경 종료 중..."
                    docker rm -f amp_backend || echo "레거시 환경 컨테이너를 종료할 수 없습니다. 이미 제거되었을 수 있습니다."
                  fi
                fi
                
                # 기존 docker-compose.yml 백업 및 현재 설정 저장
                if [ -f "docker-compose.yml" ]; then
                  cp docker-compose.yml docker-compose.yml.backup
                fi
                
                # 현재 동작 중인 환경 설정을 기본 docker-compose.yml로 저장
                cp docker-compose.${NEW_ENV}.yml docker-compose.yml
                echo "docker-compose 설정을 업데이트했습니다."
                
                echo "=== 서버 블루-그린 배포 성공 ==="
                echo "배포 시간: $(date)"
                echo "배포된 환경: ${NEW_ENV} (포트: ${NEW_PORT})"
                exit 0
              else
                echo "Nginx 설정 유효성 검사 실패, 롤백 진행..."
                echo "Nginx 오류 로그:"
                sudo cat /var/log/nginx/error.log | tail -n 20
                
                sudo cp /etc/nginx/sites-available/api.ampmusic.im.backup /etc/nginx/sites-available/api.ampmusic.im
                sudo systemctl reload nginx
                
                # 새 배포 실패, 컨테이너 제거
                echo "실패한 컨테이너 (${NEW_ENV}) 제거 중..."
                docker rm -f amp_backend_${NEW_ENV} || echo "컨테이너를 제거할 수 없습니다. 이미 제거되었을 수 있습니다."
                
                echo "Nginx 설정 오류로 인한 롤백 완료"
                exit 1
              fi
            else
              echo "❌ 헬스 체크 실패: 애플리케이션이 정상적으로 실행되지 않았습니다."
              echo "==========================="
              
              echo "새 버전 헬스 체크 실패, 롤백 진행..."
              
              # 실패 기록 추가
              DEPLOY_LOG_DIR="deployment_logs"
              mkdir -p $DEPLOY_LOG_DIR
              TIMESTAMP=$(date "+%Y%m%d-%H%M%S")
              
              # 진단 정보 저장
              DIAGNOSTIC_FILE="$DEPLOY_LOG_DIR/failure_${NEW_ENV}_${TIMESTAMP}.log"
              echo "==== 배포 실패 진단 정보 ====" > $DIAGNOSTIC_FILE
              echo "환경: ${NEW_ENV}" >> $DIAGNOSTIC_FILE
              echo "포트: ${NEW_PORT}" >> $DIAGNOSTIC_FILE
              echo "시간: $(date)" >> $DIAGNOSTIC_FILE
              echo "\n--- 컨테이너 상태 ---" >> $DIAGNOSTIC_FILE
              docker ps -a >> $DIAGNOSTIC_FILE 2>&1
              echo "\n--- 컨테이너 로그 ---" >> $DIAGNOSTIC_FILE
              docker logs amp_backend_${NEW_ENV} --tail 100 >> $DIAGNOSTIC_FILE 2>&1 || echo "로그를 가져올 수 없습니다." >> $DIAGNOSTIC_FILE
              echo "\n--- 시스템 상태 ---" >> $DIAGNOSTIC_FILE
              df -h >> $DIAGNOSTIC_FILE
              free -h >> $DIAGNOSTIC_FILE
              echo "\n--- 네트워크 상태 ---" >> $DIAGNOSTIC_FILE
              netstat -tulpn >> $DIAGNOSTIC_FILE 2>&1 || echo "네트워크 상태를 가져올 수 없습니다." >> $DIAGNOSTIC_FILE
              
              # 실패 기록 업데이트
              echo "${TIMESTAMP} - ${NEW_ENV} 환경 (포트: ${NEW_PORT}) 배포 실패 - 진단 파일: $DIAGNOSTIC_FILE" >> $DEPLOY_LOG_DIR/deploy_history.log
              
              echo "실패 진단 정보가 $DIAGNOSTIC_FILE에 저장되었습니다."
              echo "컨테이너 상태 확인:"
              docker ps -a
              
              # 애플리케이션 로그 확인
              echo "실패한 컨테이너의 마지막 로그:"
              docker logs amp_backend_${NEW_ENV} --tail 50 || echo "로그를 가져올 수 없습니다. 컨테이너가 생성되지 않았을 수 있습니다."
              
              # 새 배포 실패, 컨테이너 제거
              echo "실패한 컨테이너 (${NEW_ENV}) 제거 중..."
              docker rm -f amp_backend_${NEW_ENV} || echo "컨테이너를 제거할 수 없습니다. 이미 생성되지 않았을 수 있습니다."
              
              # 레거시 환경으로 롤백 처리
              if [ "$CURRENT_ENV" = "legacy" ] && [ ! -z "$LEGACY_IMAGE" ]; then
                echo "레거시 환경으로 롤백합니다..."
                
                # 레거시 이미지로 컨테이너 실행
                docker run -d --network host --name amp_backend \
                  -v $(pwd)/uploads:/app/uploads \
                  -v $(pwd)/.env:/app/.env \
                  -e PORT=4000 \
                  --restart unless-stopped \
                  $LEGACY_IMAGE
                
                # Nginx 설정 복구
                sudo cp /etc/nginx/sites-available/api.ampmusic.im.backup.legacy /etc/nginx/sites-available/api.ampmusic.im
                sudo systemctl reload nginx
                
                echo "레거시 환경으로 롤백 완료"
              fi
              
              echo "=== 서버 블루-그린 배포 실패, 롤백 완료 ==="
              exit 1
            fi

      # 보안 그룹에서 GitHub Actions IP 제거
      - name: Remove GitHub Actions IP from Security Group
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
              --group-id ${{ secrets.BACKEND_SECURITY_GROUP_ID }} \
              --protocol tcp \
              --port 22 \
              --cidr ${{ steps.ip.outputs.ipv4 }}/32